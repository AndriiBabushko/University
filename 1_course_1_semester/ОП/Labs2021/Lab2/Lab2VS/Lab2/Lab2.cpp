#include <iostream>
#include <math.h>
#include <windows.h>
#include <time.h>

int main()
{
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	srand(time(0));

	int arr[250000], method, a, b, count, i, temp1, fl, iMIN, temp2, j, temp3, step, temp4, countNUM = 0;
	float time;
	clock_t start, finish;
	printf("1 - Сортування обміном\n2 - Сортування методом вибору\n3 - Сортування вставками\n4 - Сортування методом Шелла\n");
	printf("Введіть яке саме сортування ви хочете виконати:"); scanf_s("%d", &method);
	printf("Введіть цілий розмір масиву A:");   scanf_s("%d", &count);
	printf("Введіть початкове значення масиву a (ціле):"); scanf_s("%d", &a);
	printf("Введіть кінцеве значення масиву b (ціле):"); scanf_s("%d", &b);
	if (a == b) {
		printf("Помилка. Значення а не > b.");
	}

	printf("Масив до сортування:");
	// Будуємо псевдорандомний масив та переносимо на кожному 100 єлементі наступні на но-вий рядок.
	for (i = 0; i < count; i++) {
		arr[i] = a + rand() % (b - a + 1);
		if (i % 100 == 0) {
			printf("\n%d  ", arr[i]);
			countNUM++;							// Обрахунок кілько-сті елементів у масиві(для себе)
		}
		else {
			printf("%d  ", arr[i]);
			countNUM++;							// Обрахунок кілько-сті елементів у масиві(для себе)
		}
	}
	// Виконання кожного методу сортування.
	switch (method) {
	case 1:
		// Метод "Бульбашка" або Сортування обміном.
		start = clock();						// Початок відрахунку часу
		do
		{
			fl = 0;
			for (i = 1; i < count; i++)			// Проходимо по кожному елементу у масиві
				if (arr[i - 1] > arr[i])		// Ящко елемент який стоїть перед і-тим елементом масиву більше за і-того, робимо наступний код
				{
					temp1 = arr[i];				// Присвоюємо тимча-совій змінній значення елемента i масиву
					arr[i] = arr[i - 1];		// Присвоюємо змінній i масиву значення елемента стоячого до нього
					arr[i - 1] = temp1;			// Значення елемента і при-своюємо елементу стоячого до нього(тобто змінюємо іх місцями у масиві)
					fl = 1;						// Прапор для завершення циклу коли він підійде до кінця
				}
		} while (fl);
		finish = clock();						// Зупинка відрахунку часу
		time = (float)(finish - start) / CLOCKS_PER_SEC;		// Обрахунок кілько-сті пройденого часу

		printf("\nМасив після сортування:");

		for (i = 0; i < count; i++) {			// Проходимо по кожному елементу у масиві
			if (i % 100 == 0) {					// Переносимо на кожному 100 єлементі наступні на новий рядок
				printf("\n%d  ", arr[i]);
			}
			else {
				printf("%d  ", arr[i]);
			}
		}

		printf("\nЧас виконання:%.2f", time);						// Ви-від кількості пройденого часу пройденого за виконання програми(основного коду)
		printf("\nКількість елементів у масиві:%d", countNUM);		// Обрахунок кількості елементів у масиві(для себе)

		break;
	case 2:
		start = clock();						// Початок відрахунку часу

		for (i = 0; i < count - 1; i++)			// Проходимо по кожному елементу у масиві
		{
			iMIN = i;										// Присвоєння і-того елемента мінімуму
			for (j = i + 1; j < count; j++)					// Проходжен-ня по кожному елементу у масиві починаючи з другого елемента
				if (arr[j] < arr[iMIN]) iMIN = j;			// Знаходження міні-муму другий раз для того щоб змінити місцями з другим елементом
			temp2 = arr[i];									// 84-86 - елементи змінюються місцями
			arr[i] = arr[iMIN];
			arr[iMIN] = temp2;
		}

		finish = clock();						// Зупинка відрахунку часу	
		time = (float)(finish - start) / CLOCKS_PER_SEC;		// Обрахунок кілько-сті пройденого часу	

		printf("\nМасив після сортування:");

		for (i = 0; i < count; i++) {			// Проходимо по кожному елементу у масиві
			if (i % 100 == 0) {					// Переносимо на кожному 100 єлементі наступні на новий рядок
				printf("\n%d  ", arr[i]);
			}
			else {
				printf("%d  ", arr[i]);
			}
		}

		printf("\nЧас виконання:%.2f", time);			// Вивід кількості пройде-ного часу пройденого за виконання програми(основного коду)
		printf("\nКількість елементів у масиві:%d", countNUM);		// Обрахунок кількості елементів у масиві(для себе)

		break;
	case 3:
		start = clock();		// Початок відрахунку часу

		for (i = 1; i < count; i++)		// Проходимо по кожному елементу у маси-ві
		{
			temp3 = arr[i];
			for (j = i - 1; j >= 0 && arr[j] > temp3; j--)		// Вставка елемента і масиву у потрібну позицію серед елементів arr[1], ..., arr[i-1], які вже впорядковані
			{
				arr[j + 1] = arr[j];		// Вставка елемента і масиву у потрібну позицію
				arr[j] = temp3;
			}
		}

		finish = clock();				// Зупинка відрахунку часу
		time = (float)(finish - start) / CLOCKS_PER_SEC;			// Обрахунок кількості пройденого часу

		printf("\nМасив після сортування:");

		for (i = 0; i < count; i++) {		// Проходимо по кожному елементу у маси-ві
			if (i % 100 == 0) {				// Переносимо на кожному 100 єле-менті наступні на новий рядок
				printf("\n%d  ", arr[i]);
			}
			else {
				printf("%d  ", arr[i]);
			}
		}

		printf("\nЧас виконання:%.1f", time);				// Вивід кількості пройденого часу пройденого за виконання програми(основного коду)
		printf("\nКількість елементів у масиві:%d", countNUM);		// Обрахунок кількості елементів у масиві(для себе)

		break;
	case 4:
		start = clock();		// Початок відрахунку часу

		step = count / 2;		// Масив уявно ділиться на підмасиви, кожен з них впо-рядковується окремо
		while (step > 0)
		{
			for (i = 0; i < (count - step); i++)		//  Масив йде саме до його половини розміру
			{
				j = i;
				while (j >= 0 && arr[j] > arr[j + step])		// цикл для одночас-ного сортування 1 підмасиву за 2
				{
					temp4 = arr[j];						// 149-152 - зміна елементів місцями в межах підмасиву
					arr[j] = arr[j + step];
					arr[j + step] = temp4;
					j--;
				}
			}
			step = step / 2;		// Підмасиви утворюються елементами через один.
		}

		finish = clock();				// Зупинка відрахунку часу
		time = (float)(finish - start) / CLOCKS_PER_SEC;			// Обрахунок кількості пройденого часу

		printf("\nМасив після сортування:");

		for (i = 0; i < count; i++) {			// Проходимо по кожному елементу у масиві
			if (i % 100 == 0) {					// Переносимо на кожному 100 єлементі наступні на новий рядок
				printf("\n%d  ", arr[i]);
			}
			else {
				printf("%d  ", arr[i]);
			}
		}

		printf("\nЧас виконання:%.1f", time);				// Вивід кількості пройденого часу пройденого за виконання програми(основного коду)
		printf("\nКількість елементів у масиві:%d", countNUM);		// Обрахунок кількості елементів у масиві(для себе)

		break;
	}
	return 0;
}